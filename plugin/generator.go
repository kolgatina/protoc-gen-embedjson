package plugin

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/alta/protopatch/patch/gopb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/dynamicpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func Run() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			filename := filepath.Base(file.GeneratedFilenamePrefix) + "_json.pb.go"
			outputPath := filepath.Join(filepath.Dir(file.Desc.Path()), filename)

			embedded := collectEmbeddedMessages(file.Messages)
			if len(embedded) == 0 {
				_ = os.Remove(outputPath)
				continue
			}

			g := plugin.NewGeneratedFile(filename, file.GoImportPath)
			g.P("// Code generated by protoc-gen-embedjson. DO NOT EDIT.")
			g.P("package ", file.GoPackageName)
			g.P(`import "encoding/json"`)

			for _, emb := range embedded {
				generateJSONMethods(g, emb.msg, emb.field)
			}
		}
		return nil
	})
}

type embeddedInfo struct {
	msg   *protogen.Message
	field *protogen.Field
}

func collectEmbeddedMessages(messages []*protogen.Message) []embeddedInfo {
	var result []embeddedInfo
	for _, msg := range messages {
		for _, nested := range collectEmbeddedMessages(msg.Messages) {
			result = append(result, nested)
		}

		if msg.Desc.IsMapEntry() {
			continue
		}

		if field := findEmbeddedField(msg); field != nil {
			result = append(result, embeddedInfo{msg: msg, field: field})
		}
	}
	return result
}

func generateJSONMethods(g *protogen.GeneratedFile, msg *protogen.Message, embedField *protogen.Field) {
	embedType := embedField.Message.GoIdent.GoName
	structName := msg.GoIdent.GoName

	// MarshalJSON
	g.P()
	g.P(fmt.Sprintf("func (r *%s) MarshalJSON() ([]byte, error) {", structName))
	g.P(fmt.Sprintf("\tif r.%s == nil {", embedType))
	g.P("\t\treturn json.Marshal(struct{}{})")
	g.P("\t}")
	g.P(fmt.Sprintf("\treturn json.Marshal(r.%s)", embedType))
	g.P("}")

	// UnmarshalJSON
	g.P()
	g.P(fmt.Sprintf("func (r *%s) UnmarshalJSON(data []byte) error {", structName))
	g.P(fmt.Sprintf("\tif r.%s == nil {", embedType))
	g.P(fmt.Sprintf("\t\tr.%s = &%s{}", embedType, embedType))
	g.P("\t}")
	g.P(fmt.Sprintf("\treturn json.Unmarshal(data, r.%s)", embedType))
	g.P("}")
}

// findEmbeddedField finds fields with `(go.field).embed = true`
func findEmbeddedField(msg *protogen.Message) *protogen.Field {
	for _, field := range msg.Fields {
		opts, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
		if !ok || opts == nil {
			continue
		}

		extVal := proto.GetExtension(opts, gopb.E_Field)
		protoMsg, ok := extVal.(proto.Message)
		if !ok {
			continue
		}

		dyn := dynamicpb.NewMessage(protoMsg.ProtoReflect().Descriptor())
		bin, err := proto.Marshal(protoMsg)
		if err != nil {
			continue
		}

		err = proto.Unmarshal(bin, dyn)
		if err != nil {
			continue
		}

		embedField := dyn.Descriptor().Fields().ByName("embed")
		if embedField == nil {
			continue
		}

		val := dyn.Get(embedField)
		if val.Bool() {
			return field
		}
	}
	return nil
}
